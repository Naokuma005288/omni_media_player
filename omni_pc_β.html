<!DOCTYPE html>
<html lang="ja" data-lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Omni Player PC - Mobile Audio Fix + Glassy UI</title>
<script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>

<style>
  :root{
    --bg:#0a0d12; --panel:#0e131a; --panel2:#0b1016; --text:#eaf0f6; --muted:#a9b8cc;
    --accent:#2d7ef7; --ok:#2ecc71; --danger:#e45656; --shadow:rgba(0,0,0,.38);
    --glass1: rgba(14,18,24,.24);
    --glass2: rgba(14,18,24,.36);
    --chip:  rgba(255,255,255,.08);
    --chip-bd: rgba(255,255,255,.14);
    --ring: rgba(120,170,255,.24);
  }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--text);
    font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Yu Gothic UI",sans-serif;
    letter-spacing:.01em; overflow:hidden; touch-action:manipulation;
  }
  body.hide-cursor{cursor:none}

  .player-shell{position:fixed; inset:0; display:flex; background:#000}
  .op-player-wrap{position:relative; flex:1; overflow:hidden; background:#000}
  video{position:absolute; inset:0; width:100%; height:100%; object-fit:contain; background:#000; z-index:1}

  /* ===== Tap-to-start overlay ===== */
  .tap-overlay{
    position:absolute; inset:0; z-index:15; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg, rgba(0,0,0,.32), rgba(0,0,0,.42));
    -webkit-backdrop-filter: blur(8px) saturate(1.1);
    backdrop-filter: blur(8px) saturate(1.1);
    transition:opacity .25s ease, visibility .25s ease;
  }
  .tap-card{
    padding:1rem 1.2rem; border-radius:16px;
    background:linear-gradient(180deg, rgba(17,22,30,.55), rgba(12,16,22,.42));
    border:1px solid rgba(255,255,255,.14);
    box-shadow:0 20px 80px var(--shadow);
    -webkit-backdrop-filter: blur(16px) saturate(1.2);
    backdrop-filter: blur(16px) saturate(1.2);
    display:flex; align-items:center; gap:.7rem;
  }
  .tap-overlay.hide{opacity:0; visibility:hidden}
  .tap-btn{
    cursor:pointer; user-select:none; display:inline-flex; align-items:center; gap:.6rem;
    padding:.55rem .9rem; border-radius:12px;
    background:radial-gradient(120% 180% at 20% 0%, rgba(255,255,255,.12), rgba(255,255,255,.04));
    border:1px solid var(--chip-bd);
    color:#fff;
    transition:transform .08s ease, filter .15s ease, box-shadow .25s ease;
    box-shadow:0 12px 40px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.06);
  }
  .tap-btn:hover{filter:brightness(1.08)}
  .tap-btn:active{transform:translateY(1px)}
  .tap-note{font-size:12px; color:var(--muted)}

  /* ===== Control Bar (glassy) ===== */
  .control-bar{
    position:absolute; left:0; right:0; bottom:0; z-index:10;
    padding:.55rem .8rem calc(.9rem + env(safe-area-inset-bottom, 0px));
    background:
      linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(8,10,14,.22) 26%, rgba(8,10,14,.36) 100%),
      radial-gradient(800px 120px at 50% 0%, rgba(255,255,255,.09), transparent 60%);
    -webkit-backdrop-filter: blur(18px) saturate(1.28);
    backdrop-filter: blur(18px) saturate(1.28);
    display:grid; gap:.6rem; grid-template-rows:auto auto; user-select:none;
    transition: opacity .24s ease, transform .24s ease;
    animation: barFadeIn .34s ease both;
    border-top:1px solid rgba(255,255,255,.10);
  }
  @keyframes barFadeIn { from{opacity:0; transform:translateY(10px)} to{opacity:1; transform:none} }
  .control-bar.is-hidden{ opacity:0; transform:translateY(12px); pointer-events:none; }

  .ctrl-top, .ctrl-bottom{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
  .ctrl-top{justify-content:space-between}
  .left-group, .right-group{display:flex; gap:.35rem; align-items:center; flex-wrap:wrap}

  /* Buttons (ultra-glass) */
  .btn{
    position:relative; overflow:hidden;
    height:34px; padding:.34rem .64rem; border-radius:12px;
    background:linear-gradient(180deg, var(--glass2), var(--glass1));
    color:#fff; cursor:pointer; display:inline-flex; gap:.45rem; align-items:center;
    transition:filter .15s ease, transform .06s ease, background .2s ease, box-shadow .25s ease;
    -webkit-backdrop-filter: blur(10px) saturate(1.08);
    backdrop-filter: blur(10px) saturate(1.08);
    border:1px solid rgba(255,255,255,.12);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 8px 26px rgba(0,0,0,.18);
  }
  .btn:hover{filter:brightness(1.08)}
  .btn:active{transform:translateY(1px) scale(.99)}
  .btn.ghost{ background:var(--chip); border:1px solid var(--chip-bd) }
  .btn.ok{ border-color:#1d6e3b; background:linear-gradient(180deg,rgba(18,38,28,.62),rgba(12,28,21,.44)) }
  .btn.active{ box-shadow:0 0 0 1px var(--ring) inset, 0 10px 28px rgba(45,126,247,.28) }

  .ripple{ position:absolute; border-radius:50%; transform:scale(0);
    background:radial-gradient(circle, rgba(255,255,255,.35) 0%, rgba(255,255,255,.06) 60%, transparent 70%);
    animation:ripple .6s ease-out forwards; pointer-events:none; }
  @keyframes ripple { to{ transform:scale(10); opacity:0 } }

  .time{min-width:80px; text-align:center; color:var(--muted)}
  .spacer{flex:1}

  .seek{
    --bg: rgba(255,255,255,.06);
    --bd: rgba(255,255,255,.14);
    flex:1; display:flex; align-items:center; gap:.6rem;
    background:var(--bg); border:1px solid var(--bd);
    border-radius:999px; padding:.35rem .6rem;
    -webkit-backdrop-filter: blur(10px) saturate(1.06);
    backdrop-filter: blur(10px) saturate(1.06);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  }
  .seek[data-buffer] input[type=range]{
    background:
      linear-gradient(to right,
        rgba(255,255,255,.22) 0%,
        rgba(255,255,255,.22) var(--buf,0%),
        transparent var(--buf,0%),
        transparent 100%);
    background-repeat:no-repeat; background-size:100% 3px; background-position:center;
    border-radius:999px;
  }
  .seek input[type=range]{width:100%; accent-color:var(--accent); appearance:none; height:18px; background:transparent}
  .seek input[type=range]::-webkit-slider-runnable-track{height:3px; background:rgba(255,255,255,.30); border-radius:999px}
  .seek input[type=range]::-webkit-slider-thumb{appearance:none; width:14px; height:14px; border-radius:50%;
    background:#fff; border:1px solid rgba(0,0,0,.25); margin-top:-5.5px; box-shadow:0 2px 10px rgba(0,0,0,.35)}
  .seek input[type=range]::-moz-range-track{height:3px; background:rgba(255,255,255,.30); border-radius:999px}
  .seek input[type=range]::-moz-range-thumb{width:14px; height:14px; border-radius:50%; background:#fff; border:1px solid rgba(0,0,0,.25)}

  .sliders{display:flex; gap:.6rem; align-items:center; flex-wrap:wrap}
  .sliders .lab{font-size:12px; color:var(--muted)}
  .sliders input[type=range]{ width:120px }
  .sliders select{
    height:34px; min-width:92px;
    background:var(--chip); border:1px solid var(--chip-bd);
    color:#fff; border-radius:10px; padding:.2rem .6rem;
    -webkit-backdrop-filter: blur(8px) saturate(1.04); backdrop-filter: blur(8px) saturate(1.04);
  }

  .seek-tip{
    position:absolute; transform:translate(-50%, -110%);
    padding:.28rem .5rem; border-radius:10px; font-size:12px;
    background:rgba(15,18,24,.70); border:1px solid rgba(255,255,255,.14); color:#fff;
    -webkit-backdrop-filter: blur(10px) saturate(1.1); backdrop-filter: blur(10px) saturate(1.1);
    pointer-events:none; z-index:20; opacity:0; transition:opacity .12s ease, transform .12s ease; white-space:nowrap;
  }
  .seek-tip.show{ opacity:1; transform:translate(-50%, -120%) }

  /* Panels */
  .panel-scrim{ position:absolute; inset:0; z-index:20; display:none; background:rgba(0,0,0,.35); -webkit-backdrop-filter:blur(4px); backdrop-filter:blur(4px) }
  .panel-scrim.show{display:block}
  .panel{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(960px,92vw); max-height:min(78vh,780px); overflow:auto;
    background:linear-gradient(180deg, rgba(16,22,30,.58), rgba(12,18,26,.46));
    border:1px solid rgba(255,255,255,.14); border-radius:16px;
    box-shadow:0 18px 80px var(--shadow);
    -webkit-backdrop-filter: blur(20px) saturate(1.26); backdrop-filter: blur(20px) saturate(1.26);
    padding:1rem 1rem 1.1rem; color:var(--text); animation: pop .2s ease;
  }
  @keyframes pop { from{transform:translate(-50%,-51%) scale(.985); opacity:.92} to{transform:translate(-50%,-50%) scale(1); opacity:1} }
  .panel h3{margin:.2rem 0 .8rem}
  .grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:.8rem}
  .card{background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:.7rem}
  .row{display:flex; gap:.5rem; align-items:center; margin:.4rem 0; flex-wrap:wrap}
  .row input[type=text], .row input[type=url], .row input[type=number], .row select{
    flex:1; min-width:0; background:#0a0f15; color:#fff; border:1px solid rgba(255,255,255,.18); border-radius:10px; padding:.5rem .6rem;
  }
  .subtle{color:var(--muted); font-size:12px}
  .kbd-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:.5rem}
  .kbd{background:#0a0f15; border:1px solid rgba(255,255,255,.14); border-radius:10px; padding:.5rem}
  .kbd kbd{background:#10161f; border:1px solid #273346; border-radius:6px; padding:.12rem .4rem; margin-right:.3rem}
  .badge{font-size:12px; color:var(--muted); border:1px solid rgba(255,255,255,.18); padding:.16rem .5rem; border-radius:999px; background:rgba(255,255,255,.05)}

  /* EQ UI */
  .eq-grid{display:grid; grid-template-columns:repeat(2,1fr); gap:.55rem}
  .eq-band{display:flex; align-items:center; gap:.5rem}
  .eq-band label{width:64px; color:var(--muted); font-size:12px}
  .eq-band output{width:46px; text-align:right; color:var(--muted); font-variant-numeric:tabular-nums}
  .eq-band input[type=range]{flex:1; accent-color:var(--accent)}
  .eq-row{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
  .eq-row select{ background:#0a0f15; color:#fff; border:1px solid rgba(255,255,255,.18); border-radius:10px; padding:.4rem .6rem; }

  /* small landscape */
  @media (orientation: landscape) and (max-height: 480px){
    .control-bar{padding:.46rem .55rem calc(.55rem + env(safe-area-inset-bottom, 0px)); gap:.45rem}
    .btn{height:30px; padding:.24rem .5rem; font-size:13px}
    .seek{padding:.28rem .5rem}
    .time{min-width:56px; font-size:12px}
    .sliders{gap:.45rem}
    .sliders{display:none}
  }

  /* Background FX */
  .opfx { position:absolute; inset:0; z-index:0; pointer-events:none; overflow:hidden; }
  .opfx .fx-layer { position:absolute; inset:-10%; filter:saturate(1.06); opacity:.5; }
  .opfx .grad {
    background: radial-gradient(1200px 800px at 20% 30%, rgba(45,126,247,.22), transparent 60%),
                radial-gradient(1200px 800px at 80% 70%, rgba(99,251,215,.16), transparent 60%),
                linear-gradient(180deg, rgba(0,0,0,.08), transparent 60%);
    animation: pan 28s linear infinite alternate;
  }
  .opfx .grain {
    opacity:.06;
    background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='140' height='140' viewBox='0 0 140 140'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='2' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
    background-size:420px 420px;
    animation:jitter 1.8s steps(2,end) infinite;
  }
  .opspec-canvas { position:absolute; inset:0; z-index:2; pointer-events:none; mix-blend-mode:screen; opacity:.96; transition:opacity .25s ease; }
  .opspec-hidden { opacity:0 }
  @keyframes pan{0%{transform:translate3d(-2%,-2%,0) scale(1.02)}100%{transform:translate3d(2%,2%,0) scale(1.02)}}
  @keyframes jitter{0%{transform:translate3d(0,0,0)}100%{transform:translate3d(-1px,1px,0)}}
</style>
</head>
<body>
  <div class="player-shell">
    <div class="op-player-wrap" id="wrap">
      <video id="v" playsinline crossorigin="anonymous" preload="metadata"></video>

      <!-- Tap to start (mobile audio unlock) -->
      <div class="tap-overlay" id="tap">
        <div class="tap-card">
          <button class="tap-btn" id="tapBtn">▶︎ タップで開始 / Tap to start</button>
          <div class="tap-note">（モバイルのオーディオ制限を解除します）</div>
        </div>
      </div>

      <!-- Control Bar -->
      <div class="control-bar" id="ctrl">
        <div class="ctrl-top">
          <div class="left-group">
            <button class="btn" id="btnPlay" data-i18n="btn_play">再生/一時停止</button>
            <button class="btn ghost" id="btnBack" data-i18n="btn_back">-10s</button>
            <button class="btn ghost" id="btnFwd" data-i18n="btn_fwd">+10s</button>
            <span class="badge" id="badgeState">IDLE</span>
          </div>
          <div class="right-group">
            <button class="btn ghost" id="btnTips" data-i18n="btn_tips">Tips</button>
            <button class="btn ghost" id="btnSettings" data-i18n="btn_settings">設定</button>
            <button class="btn ghost" id="btnLoop" data-i18n="btn_loop">Loop</button>
            <button class="btn ghost" id="btnPip" data-i18n="btn_pip">PiP</button>
            <button class="btn ghost" id="btnFs" data-i18n="btn_fs">FS</button>
            <button class="btn ghost" id="btnLang" title="Lang">🌐</button>
          </div>
        </div>

        <div class="ctrl-bottom">
          <div class="seek" id="seekWrap">
            <span class="time" id="cur">0:00</span>
            <input id="seek" type="range" min="0" max="1000" step="1" value="0" />
            <span class="time" id="dur">0:00</span>
          </div>
          <div class="spacer"></div>
          <div class="sliders">
            <span class="lab" data-i18n="label_volume">音量</span>
            <input id="vol" type="range" min="0" max="1" step="0.01" value="0.9" />
            <span class="lab" data-i18n="label_rate">速度</span>
            <select id="rateSel" aria-label="Playback rate">
              <option value="0.25">0.25x</option>
              <option value="0.50">0.50x</option>
              <option value="0.75">0.75x</option>
              <option value="1.00" selected>1.00x</option>
              <option value="1.25">1.25x</option>
              <option value="1.50">1.50x</option>
              <option value="1.75">1.75x</option>
              <option value="2.00">2.00x</option>
            </select>
            <span class="lab" data-i18n="label_sleep">タイマー</span>
            <select id="sleepSel" aria-label="Sleep timer">
              <option value="0">Off</option>
              <option value="300">5m</option>
              <option value="600">10m</option>
              <option value="1800">30m</option>
              <option value="3600">60m</option>
            </select>
          </div>
        </div>
      </div>

      <!-- seek tooltip -->
      <div class="seek-tip" id="seekTip">0:00</div>

      <!-- Settings -->
      <div class="panel-scrim" id="settingsScrim">
        <div class="panel" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
          <h3 id="settingsTitle" data-i18n="settings_title">設定</h3>
          <div class="grid">
            <div class="card">
              <div class="row"><strong data-i18n="source_title">ソース</strong></div>
              <div class="row">
                <input id="url" type="url" placeholder="https:// (.m3u8 / .mp4 / .mp3 ...)" />
                <button class="btn ok" id="openUrl" data-i18n="open_btn">開く</button>
              </div>
              <div class="row">
                <input id="file" type="file" multiple accept="video/*,audio/*,.m3u8,.mp3,.mp4" />
              </div>
              <div class="subtle" id="source_note">m3u8はHLS.js、ローカルは file:// OK（CORS制限のあるURLは不可）</div>
            </div>

            <div class="card">
              <div class="row"><strong data-i18n="sub_title">字幕</strong></div>
              <div class="row">
                <input id="subFile" type="file" accept=".srt,.vtt" />
                <button class="btn ghost" id="btnSubClear" data-i18n="sub_clear">解除</button>
              </div>
              <div class="row"><label data-i18n="sub_size">サイズ(px)</label><input id="subSize" type="number" min="12" max="52" step="1" value="28" /></div>
              <div class="row"><label data-i18n="sub_outline">縁(px)</label><input id="subOutline" type="number" min="0" max="8" step="1" value="3" /></div>
              <div class="row"><label data-i18n="sub_margin">下マージン(px)</label><input id="subMargin" type="number" min="0" max="300" step="5" value="30" /></div>
              <div class="row"><label data-i18n="sub_offset">オフセット(ms)</label><input id="subOffset" type="number" step="50" value="0" /></div>
            </div>

            <div class="card">
              <div class="row"><strong data-i18n="spec_title">スペクトラム</strong></div>
              <div class="row">
                <label data-i18n="spec_mode">モード</label>
                <select id="specMode">
                  <option value="bars" data-i18n="spec_bars">Bars</option>
                  <option value="circular" data-i18n="spec_circ">Circular</option>
                </select>
              </div>
              <div class="row">
                <label data-i18n="spec_dist">分布</label>
                <select id="specDist">
                  <option value="log" data-i18n="spec_log">Log</option>
                  <option value="linear" data-i18n="spec_lin">Linear</option>
                </select>
              </div>
              <div class="row">
                <label data-i18n="spec_balance">バランス</label><input id="specTilt" type="range" min="-0.6" max="0.6" step="0.02" value="-0.2" />
              </div>
              <div class="row"><label data-i18n="spec_sens">感度</label><input id="specSens" type="range" min="0.5" max="1.8" step="0.01" value="1.05" /></div>
              <div class="row"><label data-i18n="spec_bins">バー本数</label><input id="specBins" type="range" min="60" max="240" step="1" value="170" /></div>
            </div>

            <!-- EQ -->
            <div class="card">
              <div class="row"><strong id="eq_title">イコライザ</strong></div>
              <div class="eq-row">
                <label id="eq_enable_lab">有効</label>
                <select id="eqEnable"><option value="on">ON</option><option value="off">OFF</option></select>
                <label id="eq_preset_lab" style="margin-left:.3rem">プリセット</label>
                <select id="eqPreset">
                  <option value="flat">Flat</option>
                  <option value="bass">Bass Boost</option>
                  <option value="treble">Treble Boost</option>
                  <option value="vocal">Vocal</option>
                  <option value="pop">Pop</option>
                  <option value="rock">Rock</option>
                  <option value="custom">Custom</option>
                </select>
                <button class="btn ghost" id="eqReset">Reset</button>
              </div>
              <div class="eq-grid" id="eqBands"></div>
              <div class="subtle" id="eq_note">-12dB〜+12dB。ON時は再生音にも適用されます。</div>
            </div>

            <div class="card">
              <div class="row"><strong data-i18n="fx_title">アニメーションFX</strong></div>
              <div class="row">
                <label data-i18n="fx_preset">プリセット</label>
                <select id="fxPreset">
                  <option value="minimal" data-i18n="fx_minimal">Minimal</option>
                  <option value="glow" data-i18n="fx_glow">Glow</option>
                  <option value="neon" data-i18n="fx_neon">Neon</option>
                  <option value="clean" data-i18n="fx_clean">Clean</option>
                </select>
              </div>
              <div class="row">
                <label id="gridfx_lab">停止中のグリッド</label>
                <select id="gridFx">
                  <option value="on">ON</option>
                  <option value="off">OFF</option>
                </select>
              </div>
              <div class="subtle" id="fx_note">重い時は Clean / Minimal を</div>
            </div>
          </div>

          <div class="row" style="justify-content:flex-end; margin-top:.8rem">
            <button class="btn ghost" id="btnCloseSettings" data-i18n="close_btn">閉じる (Esc)</button>
          </div>
        </div>
      </div>

      <!-- Tips -->
      <div class="panel-scrim" id="tipsScrim">
        <div class="panel" role="dialog" aria-modal="true" aria-labelledby="tipsTitle">
          <h3 id="tipsTitle">Tips / Shortcuts</h3>
          <div id="tipsBody" class="kbd-grid"></div>
          <div class="row" style="justify-content:flex-end; margin-top:.8rem">
            <button class="btn ghost" id="btnCloseTips" data-i18n="close_btn">閉じる (Esc)</button>
          </div>
        </div>
      </div>

      <!-- BG FX -->
      <div class="opfx preset-minimal"><div class="fx-layer grad"></div><div class="fx-layer grain"></div></div>

    </div>
  </div>

<!-- Ripple -->
<script>
document.addEventListener('click', function(e){
  const b = e.target.closest('.btn'); if(!b) return;
  const r = document.createElement('span'); r.className='ripple';
  const rect = b.getBoundingClientRect();
  const size = Math.max(rect.width, rect.height);
  r.style.width = r.style.height = size + 'px';
  r.style.left = (e.clientX - rect.left - size/2) + 'px';
  r.style.top  = (e.clientY - rect.top  - size/2) + 'px';
  b.appendChild(r);
  setTimeout(()=> r.remove(), 650);
}, {passive:true});
</script>

<!-- ===== Audio graph (EQ) — mobile safe ===== -->
<script>
(()=> {
  const FREQS = [32,64,125,250,500,1000,2000,4000,8000,16000];
  const PRESETS = {
    flat:  [0,0,0,0,0,0,0,0,0,0],
    bass:  [6,5,4,2,0,-1,-2,-3,-4,-4],
    treble:[-3,-3,-2,-1,0,1,3,4,5,6],
    vocal: [-2,-1,0,2,3,3,2,0,-1,-2],
    pop:   [0,2,3,2,0,0,2,3,2,0],
    rock:  [4,3,1,-1,-2,0,2,3,4,5]
  };
  const clamp=(x,a,b)=>Math.min(b,Math.max(a,x));

  const OPAudio = {
    ctx:null, src:null, analyser:null,
    preGain:null, filters:[], eqEnabled:true,
    usingGraph:false, safeFallback:true, // fallback = 要求時に素の再生に戻す
    _video:null,

    async ensure(video){
      // すでにセット済みなら状態だけ確認
      if (this._video !== video){ this._video = video; this.resetGraph(); }

      // AudioContextは「ユーザー操作後に」作成/再開
      if (!this.ctx) {
        try{ this.ctx = new (window.AudioContext||window.webkitAudioContext)(); }
        catch(e){ this.safeFallback = true; return; }
      }
      if (this.ctx.state !== 'running'){
        try{ await this.ctx.resume(); }catch(e){}
      }

      // ノード未構築なら作る
      if (!this.analyser){
        try{
          this.analyser = this.ctx.createAnalyser();
          this.analyser.fftSize = 2048;
          this.analyser.smoothingTimeConstant = .84;
        }catch(e){ this.safeFallback=true; return; }
      }
      if (!this.preGain){
        try{
          this.preGain = this.ctx.createGain(); this.preGain.gain.value = 1.0;
        }catch(e){ this.safeFallback=true; return; }
      }
      if (this.filters.length===0){
        const gains = this._loadGains();
        for(let i=0;i<FREQS.length;i++){
          const f = this.ctx.createBiquadFilter();
          f.type = (i===0) ? 'lowshelf' : (i===FREQS.length-1 ? 'highshelf' : 'peaking');
          f.frequency.value = FREQS[i];
          f.Q.value = (f.type==='peaking') ? 0.9 : 0.707;
          f.gain.value = gains[i]||0;
          this.filters.push(f);
        }
        this.eqEnabled = this._loadEnabled();
      }

      // MediaElementSource は1個だけ許容。失敗時は素の再生へ。
      if (!this.src){
        try{
          this.src = this.ctx.createMediaElementSource(video);
        }catch(e){
          // Safariで既に作られている/制限など…→フォールバック
          this.safeFallback = true;
          this.usingGraph = false;
          video.muted = false;
          return;
        }
      }

      this.reconnect();
    },

    reconnect(){
      if (!this.src || !this.analyser){ this.usingGraph=false; return; }
      // いったん切断
      try{ this.src.disconnect(); }catch{}
      try{ this.preGain.disconnect(); }catch{}
      for(const n of this.filters){ try{ n.disconnect(); }catch{} }
      try{ this.analyser.disconnect(); }catch{}

      // NOTE:
      //  - グラフに流す場合は video.muted=true（二重出力回避）
      //  - フォールバック時は video.muted=false（素の音）
      if (this.eqEnabled){
        this._connectEqChain();
        this.usingGraph = true;
        this._video.muted = true;
      }else{
        // EQ無効でもアナライザには分岐接続（スペクトラム用）
        try{
          this.src.connect(this.analyser);
        }catch{}
        this.usingGraph = false;
        this._video.muted = false;
      }
    },

    _connectEqChain(){
      let node = this.src;
      try{
        node.connect(this.preGain); node = this.preGain;
        for(const f of this.filters){ node.connect(f); node = f; }
        node.connect(this.analyser);
        this.analyser.connect(this.ctx.destination);
      }catch(e){
        // 接続失敗 → フォールバック
        try{ this.src.connect(this.analyser); }catch{}
        this._video.muted = false;
        this.usingGraph = false;
        this.safeFallback = true;
      }
    },

    setEnabled(on){
      this.eqEnabled = !!on;
      this._saveEnabled(this.eqEnabled);
      this.reconnect();
    },

    setBand(i, gain){
      if(!this.filters[i]) return;
      this.filters[i].gain.value = clamp(+gain, -12, 12);
      this._saveGains();
    },
    setPreset(name){
      const g = PRESETS[name] || PRESETS.flat;
      for(let i=0;i<g.length;i++){ this.setBand(i, g[i]); }
    },
    getGains(){ return this.filters.map(f=> Number(f.gain.value.toFixed(2))); },

    resetGraph(){
      try{ this.src?.disconnect(); }catch{}
      try{ this.preGain?.disconnect(); }catch{}
      try{ this.analyser?.disconnect(); }catch{}
      this.src=null; this.usingGraph=false;
      if (this._video) this._video.muted=false;
    },

    _saveGains(){ try{ localStorage.setItem('pc.eq.gains', JSON.stringify(this.getGains())); }catch{} },
    _loadGains(){ try{ const s=JSON.parse(localStorage.getItem('pc.eq.gains')||'[]'); if(Array.isArray(s)&&s.length===FREQS.length) return s; }catch{} return PRESETS.flat.slice(); },
    _saveEnabled(v){ try{ localStorage.setItem('pc.eq.enabled', v?'1':'0'); }catch{} },
    _loadEnabled(){ try{ return localStorage.getItem('pc.eq.enabled')!=='0'; }catch{} }
  };

  window.OPAudio = OPAudio;
  window.OPAudio_FREQS = FREQS;
  window.OPAudio_PRESETS = PRESETS;
})();
</script>

<!-- ===== Spectrum (uses OPAudio analyser) + Pause Grid FX ===== -->
<script>
(()=>{ const clamp=(x,a,b)=>Math.min(b,Math.max(a,x));
  const OPSpectrum={
    overlayOnVideo:true, sens:1.05, bins:170, offsetBottom:18,
    dist:'log', tilt:-0.2, smooth:0.28, gridEnabled:true,
    _ctx:null,_analyser:null,_raf:0,_mode:'bars',
    _canvas:null,_g:null,_video:null,_prev:null,_gain:1,_p95:0.8,_gridAlpha:0,

    setMode(m){this._mode=(m==='circular')?'circular':'bars';},
    setDist(d){this.dist=(d==='linear')?'linear':'log';},
    setTilt(t){this.tilt=+t||0},
    setGrid(on){this.gridEnabled=!!on;},

    _ensureCanvas(wrap){
      if(this._canvas&&this._canvas.isConnected) return;
      const c=document.createElement('canvas'); c.id='op-spectrum-canvas'; c.className='opspec-canvas';
      wrap.appendChild(c); this._canvas=c; this._g=c.getContext('2d',{alpha:true});
      const fit=()=>{const r=wrap.getBoundingClientRect(); c.width=Math.max(1,Math.floor(r.width*devicePixelRatio)); c.height=Math.max(1,Math.floor(r.height*devicePixelRatio));};
      fit(); new ResizeObserver(fit).observe(wrap);
    },

    _bindAnalyser(){
      if (window.OPAudio && OPAudio.analyser){ this._ctx = OPAudio.ctx; this._analyser = OPAudio.analyser; return true; }
      return false;
    },

    _mapIndices(n, sampleRate){
      const N=this._analyser.frequencyBinCount; const nyq=sampleRate/2;
      const idx=[]; let prev=0;
      if(this.dist==='linear'){
        const step=(N-1)/n;
        for(let i=1;i<=n;i++){ const k=Math.round(i*step); idx.push([prev,k]); prev=k+1; }
      }else{
        const fMin=30, fMax=Math.max(18000, nyq);
        for(let i=1;i<=n;i++){
          const t=i/n;
          const f = fMin * Math.pow(fMax/fMin, t);
          const k = clamp(Math.round((f/nyq)*(N-1)), 0, N-1);
          idx.push([prev, k]); prev=k+1;
        }
      }
      idx[idx.length-1][1]=N-1;
      return idx;
    },

    _drawGrid(g,W,H){
      if(!this.gridEnabled) return;
      const target = (this._video && (this._video.paused || this._video.readyState<2)) ? 0.85 : 0;
      this._gridAlpha = this._gridAlpha*0.88 + target*0.12;
      if(this._gridAlpha < 0.02) return;

      const pad=Math.round(12*devicePixelRatio);
      const spacing = Math.round(22*devicePixelRatio);
      const t = performance.now()/1000;
      const offY = (t*18*devicePixelRatio)%spacing;
      const offX = (t*12*devicePixelRatio)%spacing;

      g.save();
      g.globalAlpha = this._gridAlpha;
      g.lineWidth = Math.max(1, 1*devicePixelRatio);

      const grd = g.createLinearGradient(0,0,W,H);
      grd.addColorStop(0,'rgba(200,220,255,0.18)');
      grd.addColorStop(1,'rgba(140,170,255,0.10)');
      g.strokeStyle = grd;

      g.beginPath();
      for(let y=pad+offY; y<H-pad; y+=spacing){ g.moveTo(pad,y); g.lineTo(W-pad,y); }
      g.stroke();

      g.beginPath();
      for(let x=pad+offX; x<W-pad; x+=spacing){ g.moveTo(x,pad); g.lineTo(x,H-pad); }
      g.stroke();
      g.restore();
    },

    _drawLoop(){
      cancelAnimationFrame(this._raf);
      const g=this._g, c=this._canvas, an=this._analyser, ctx=this._ctx; if(!g||!c||!an||!ctx) return;
      const n=clamp(this.bins|0, 16, 360);
      const data=new Uint8Array(an.frequencyBinCount); this._prev ??= new Float32Array(n);
      const map=this._mapIndices(n, ctx.sampleRate);

      const render=()=>{
        this._raf=requestAnimationFrame(render);
        an.getByteFrequencyData(data);

        const arr=new Float32Array(n);
        for(let i=0;i<n;i++){
          const [s,e]=map[i]; let peak=0;
          for(let k=s;k<=e;k++){ const v=data[k]||0; if(v>peak) peak=v; }
          let amp=(peak/255)*this.sens;
          const pos=i/(n-1); const tilt=this.tilt;
          if(tilt!==0){
            const w=Math.pow(pos, tilt>0 ? (1+tilt*1.6) : (1/(1+(-tilt*1.6))));
            amp *= (0.6 + 0.8*w);
          }
          arr[i]=amp;
        }

        // AGC
        const tmp=Array.from(arr).sort((a,b)=>a-b);
        const p95=tmp[Math.floor(tmp.length*0.95)]||0.001;
        this._p95=this._p95*0.92 + p95*0.08;
        const targetGain = 0.9 / Math.max(0.05, this._p95);
        this._gain=this._gain*0.9 + targetGain*0.1;
        for(let i=0;i<n;i++){ arr[i]=Math.min(1, arr[i]*this._gain); }

        // EMA smoothing
        const alpha=Math.min(.6, Math.max(.05, this.smooth));
        for(let i=0;i<n;i++){ this._prev[i]=this._prev[i]*(1-alpha) + arr[i]*alpha; }

        // draw
        g.clearRect(0,0,c.width,c.height);
        const pad=Math.round(12*devicePixelRatio), W=c.width, H=c.height;
        const bottom=Math.round(this.offsetBottom*devicePixelRatio), baseY=H-bottom-pad;

        // grid under bars
        this._drawGrid(g,W,H);

        if(this._mode==='circular'){
          const cx=W/2, cy=H - Math.max(H*.28, 180*devicePixelRatio);
          const radius=Math.min(W,H)*.22; g.save(); g.translate(cx,cy);
          const bins=n, seg=(Math.PI*2)/bins;
          for(let i=0;i<bins;i++){
            const amp=this._prev[i]; const len=radius*(0.35 + amp*0.95); const a=i*seg;
            const x1=Math.cos(a)*(radius*.65), y1=Math.sin(a)*(radius*.65);
            const x2=Math.cos(a)*len, y2=Math.sin(a)*len;
            g.strokeStyle='rgba(88,170,255,'+(0.30 + amp*0.55)+')';
            g.lineWidth=Math.max(1, Math.min(6*devicePixelRatio, 1.2*devicePixelRatio + amp*4*devicePixelRatio));
            g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();
          }
          g.restore();
        }else{
          const bins=n, w=(W-pad*2)/bins;
          for(let i=0;i<bins;i++){
            const amp=this._prev[i]; const h=Math.min(baseY-pad, amp*(H*.5));
            const x=pad+i*w, y=baseY-h;
            g.fillStyle='rgba(255,255,255,0.05)';
            g.fillRect(x, baseY-Math.max(2*devicePixelRatio, h*0.08), Math.max(1,w*.9), Math.max(2*devicePixelRatio, h*0.08));
            g.fillStyle='rgba(45,126,247,'+(0.20 + amp*0.55)+')';
            g.fillRect(x,y,Math.max(1,w*.9),h);
          }
        }
      };
      render();
    },

    attach(video,wrap){
      if(!video||!wrap) return;
      this._video = video;
      this._ensureCanvas(wrap);
      if(this._bindAnalyser()){
        this._canvas.classList.toggle('opspec-hidden',false);
        this._drawLoop();
      }
    }
  };
  window.OPSpectrum=OPSpectrum;
})();
</script>

<!-- ===== Main ===== -->
<script>
(function(){
  const $=sel=>document.querySelector(sel);
  const v=$('#v'), wrap=$('#wrap'), ctrl=$('#ctrl'), seekWrap=$('#seekWrap'), seekEl=$('#seek'), seekTip=$('#seekTip');
  const tap=$('#tap'), tapBtn=$('#tapBtn');

  // i18n
  const I={ ja:{ btn_play:'再生/一時停止', btn_back:'-10秒', btn_fwd:'+10秒', btn_tips:'Tips', btn_settings:'設定', btn_loop:'ループ',
    btn_pip:'PiP', btn_fs:'全画面', close_btn:'閉じる (Esc)',
    label_volume:'音量', label_rate:'速度', label_sleep:'タイマー',
    settings_title:'設定', source_title:'ソース', open_btn:'開く',
    sub_title:'字幕', sub_clear:'解除', sub_size:'サイズ(px)', sub_outline:'縁(px)', sub_margin:'下マージン(px)', sub_offset:'オフセット(ms)',
    spec_title:'スペクトラム', spec_mode:'モード', spec_bars:'Bars', spec_circ:'Circular', spec_dist:'分布', spec_log:'Log', spec_lin:'Linear', spec_balance:'バランス', spec_sens:'感度', spec_bins:'本数',
    fx_title:'アニメーションFX', fx_preset:'プリセット', fx_minimal:'Minimal', fx_glow:'Glow', fx_neon:'Neon', fx_clean:'Clean',
    tips_title:'Tips / ショートカット',
    tips:[ ['Space','再生/一時停止','←/→','10秒移動'], ['0..9','位置ジャンプ(%)','[ / ]','速度 ±1段階'],
           ['F','フルスクリーン','P','PiP'], ['M','ミュート','D','自動非表示 ON/OFF'],
           ['S','スクショPNG保存','A/B/L','ABループ 設定/設定/切替'], ['モバイル','左右ダブルタップで ±10秒','',''] ],
    badge_idle:'IDLE', badge_ready:'READY', badge_play:'再生', badge_pause:'一時停止', badge_muted:'ミュート',
    badge_play_loop:'再生・ループ', badge_pause_loop:'一時停止・ループ', badge_resume:'レジューム', badge_shot:'保存'
  }, en:{ btn_play:'Play/Pause', btn_back:'-10s', btn_fwd:'+10s', btn_tips:'Tips', btn_settings:'Settings', btn_loop:'Loop',
    btn_pip:'PiP', btn_fs:'Fullscreen', close_btn:'Close (Esc)',
    label_volume:'Vol', label_rate:'Speed', label_sleep:'Sleep',
    settings_title:'Settings', source_title:'Source', open_btn:'Open',
    sub_title:'Subtitles', sub_clear:'Clear', sub_size:'Size(px)', sub_outline:'Outline(px)', sub_margin:'Bottom margin(px)', sub_offset:'Offset(ms)',
    spec_title:'Spectrum', spec_mode:'Mode', spec_bars:'Bars', spec_circ:'Circular', spec_dist:'Distribution', spec_log:'Log', spec_lin:'Linear', spec_balance:'Balance', spec_sens:'Sensitivity', spec_bins:'Bars',
    fx_title:'Animation FX', fx_preset:'Preset', fx_minimal:'Minimal', fx_glow:'Glow', fx_neon:'Neon', fx_clean:'Clean',
    tips_title:'Tips / Shortcuts',
    tips:[ ['Space','Play/Pause','Left/Right','Seek 10s'], ['0..9','Jump (%)','[ / ]','Speed ±1 step'],
           ['F','Fullscreen','P','PiP'], ['M','Mute','D','Auto-hide toggle'],
           ['S','Save PNG','A/B/L','AB loop Set/Set/Toggle'], ['Mobile','Double-tap left/right ±10s','',''] ],
    badge_idle:'IDLE', badge_ready:'READY', badge_play:'PLAY', badge_pause:'PAUSE', badge_muted:'MUTED',
    badge_play_loop:'PLAY • LOOP', badge_pause_loop:'PAUSE • LOOP', badge_resume:'RESUME', badge_shot:'SHOT'
  }};
  function getLang(){ try{ const pref=localStorage.getItem('pc.lang'); if(pref) return pref; return (navigator.language||'ja').toLowerCase().startsWith('ja')?'ja':'en'; }catch{return 'ja'} }
  let LANG=getLang(); const t=(k)=> (I[LANG]&&I[LANG][k]) || (I.ja[k]||k);
  function applyLang(){
    document.documentElement.lang=LANG; document.documentElement.setAttribute('data-lang',LANG);
    document.querySelectorAll('[data-i18n]').forEach(el=>{ const key=el.getAttribute('data-i18n'); const txt=t(key); if(txt) el.textContent=txt; });
    $('#settingsTitle').textContent=t('settings_title'); $('#tipsTitle').textContent=t('tips_title');
    $('#source_note').textContent=(LANG==='ja')?'m3u8はHLS.js、ローカルは file:// OK（CORS制限のあるURLは不可）':'m3u8 uses HLS.js. Local file:// OK (CORS-limited URLs not supported).';
    $('#eq_title').textContent=(LANG==='ja')?'イコライザ':'Equalizer';
    $('#eq_enable_lab').textContent=(LANG==='ja')?'有効':'Enable';
    $('#eq_preset_lab').textContent=(LANG==='ja')?'プリセット':'Preset';
    $('#eq_note').textContent=(LANG==='ja')?'-12dB〜+12dB。ON時は再生音にも適用されます。':'-12dB to +12dB. Applied to playback audio when ON.';
    $('#gridfx_lab').textContent=(LANG==='ja')?'停止中のグリッド':'Pause Grid FX';
    $('#fx_note').textContent=(LANG==='ja')?'重い時は Clean / Minimal を':'If heavy, try Clean / Minimal.';
    renderTips();
  }
  function renderTips(){
    const tips = I[LANG].tips, body=$('#tipsBody'); body.innerHTML='';
    for(const row of tips){
      const div=document.createElement('div'); div.className='kbd';
      const [a1,a2,b1,b2]=row;
      const p1=document.createElement('p'); p1.innerHTML= a1? `<kbd>${a1}</kbd> ${a2||''}` : (a2||''); div.appendChild(p1);
      if(b1||b2){ const p2=document.createElement('p'); p2.innerHTML=b1? `<kbd>${b1}</kbd> ${b2||''}` : (b2||''); div.appendChild(p2); }
      body.appendChild(div);
    }
  }
  $('#btnLang').addEventListener('click',()=>{ LANG=(LANG==='ja'?'en':'ja'); try{ localStorage.setItem('pc.lang',LANG);}catch{} applyLang(); setBadge(v.paused ? t('badge_pause') : t('badge_play')); });

  function setBadge(txt){ $('#badgeState').textContent=txt; }

  // ===== Mobile Unlock =====
  async function unlockAudioAndGraph(){
    try{
      await OPAudio.ensure(v);
      OPSpectrum.attach(v, wrap);
    }catch{}
    tap.classList.add('hide');
  }
  tapBtn.addEventListener('click', async ()=>{
    await unlockAudioAndGraph();
    try{ await v.play(); }catch{}
  }, {passive:true});
  // 画面タップでも解錠
  tap.addEventListener('click', async ()=>{
    await unlockAudioAndGraph();
  }, {passive:true});

  // ===== Spectrum helper =====
  function attachSpectrumNow(bottom=18){
    OPSpectrum.offsetBottom=bottom; OPSpectrum.overlayOnVideo=true; OPSpectrum.attach(v, wrap);
  }

  // ===== State =====
  const S={ dragging:false, duration:0, subOffset:0, subTrack:null, _hls:null,
    lastUrl:null, lastBlobUrl:null, autoHide:true, autoHideMs:2600, autoHideTimer:null,
    fileList:[], fileIndex:0, wakeLock:null, loopA:null, loopB:null, loopOn:false, lastTap:0, lastTapX:0, sleepLeft:0, sleepTimer:null };
  const clamp=(x,a,b)=>Math.min(b,Math.max(a,x));
  const fmt=(t)=>{ if(!isFinite(t)||t<0) return '0:00'; const s=Math.floor(t%60).toString().padStart(2,'0'); const m=Math.floor(t/60); if(m>=60){ const h=Math.floor(m/60), mm=(m%60).toString().padStart(2,'0'); return `${h}:${mm}:${s}` } return `${m}:${s}`; };

  // ===== Times / Buffer / Seek tip =====
  function updateSeekTip(){ if(!S.dragging) return; const rect=seekEl.getBoundingClientRect(); const p=+seekEl.value/1000; const x=rect.left+rect.width*p; seekTip.style.left=x+'px'; const sec=(v.duration||0)*p; seekTip.textContent=fmt(sec); }
  function updateTimes(){
    $('#cur').textContent=fmt(v.currentTime||0); $('#dur').textContent=isFinite(v.duration)?fmt(v.duration):'0:00';
    if(!S.dragging && isFinite(v.duration)){ const p=Math.max(0,Math.min(1,(v.currentTime||0)/(v.duration||1))); seekEl.value=Math.round(p*1000); }
    try{ const buf=v.buffered; let end=0; for(let i=0;i<buf.length;i++){ end=Math.max(end, buf.end(i)||0); } const b=(isFinite(v.duration)&&v.duration>0)? (end/v.duration*100).toFixed(1)+'%':'0%'; seekWrap.style.setProperty('--buf', b); seekWrap.dataset.buffer=b; }catch{}
    updateSeekTip();
  }

  // ===== Auto Hide =====
  function showUI(){ ctrl.classList.remove('is-hidden'); document.body.classList.remove('hide-cursor'); }
  function hideUI(){ if(!S.autoHide) return; if(document.fullscreenElement && !v.paused && !isAnyPanelOpen() && !S.dragging){ ctrl.classList.add('is-hidden'); document.body.classList.add('hide-cursor'); } }
  function bumpAutoHide(){ showUI(); clearTimeout(S.autoHideTimer); if(!v.paused && !isAnyPanelOpen()){ S.autoHideTimer=setTimeout(hideUI, S.autoHideMs); } }
  const isAnyPanelOpen=()=> $('#settingsScrim').classList.contains('show') || $('#tipsScrim').classList.contains('show');

  // ===== Wake Lock =====
  async function lockWake(){ try{ if('wakeLock' in navigator && !S.wakeLock){ S.wakeLock=await navigator.wakeLock.request('screen'); S.wakeLock.addEventListener?.('release',()=>S.wakeLock=null);} }catch{} }
  async function releaseWake(){ try{ await S.wakeLock?.release(); }catch{} finally{ S.wakeLock=null; } }
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && !v.paused) lockWake(); });

  // ===== Playback =====
  $('#btnPlay').onclick=async ()=>{ await OPAudio.ensure(v); OPSpectrum.attach(v, wrap); if(v.paused){ try{ await v.play(); }catch{} } else v.pause(); };
  v.addEventListener('play', ()=>{ setBadge(S.loopOn? I[LANG].badge_play_loop : I[LANG].badge_play); lockWake(); bumpAutoHide(); tap.classList.add('hide'); });
  v.addEventListener('pause', ()=>{ setBadge(S.loopOn? I[LANG].badge_pause_loop : I[LANG].badge_pause); showUI(); releaseWake(); });
  v.addEventListener('loadedmetadata', ()=>{ S.duration=v.duration||0; updateTimes(); setBadge(I[LANG].badge_ready); });
  v.addEventListener('timeupdate', ()=>{
    if (S.loopOn && S.loopA!=null && S.loopB!=null && S.loopB>S.loopA){ if (v.currentTime > S.loopB - 0.03){ v.currentTime = S.loopA; } }
    updateTimes();
    if (S.sleepLeft>0 && !v.paused){ S.sleepLeft -= 1; updateSleepBadge(); if (S.sleepLeft<=0){ v.pause(); } }
    if(isFinite(v.duration) && Math.floor(v.currentTime)%5===0){ try{ localStorage.setItem('pc.lastUrl', S.lastUrl||''); localStorage.setItem('pc.lastTime', String(v.currentTime||0)); }catch{} }
  });
  v.addEventListener('ended', ()=>{ setBadge('ENDED'); showUI(); releaseWake(); if(S.fileList.length>0 && S.fileIndex<S.fileList.length-1){ S.fileIndex++; openLocalFile(S.fileList[S.fileIndex]); } });

  // click / double tap
  v.addEventListener('click', (e)=>{
    const now=performance.now(); const dx=Math.abs(e.clientX - S.lastTapX);
    if(now - S.lastTap < 320 && dx < 80){
      const x=e.clientX, w=wrap.clientWidth;
      if(x < w*0.4) v.currentTime = Math.max(0,(v.currentTime||0)-10);
      else if(x > w*0.6) v.currentTime = Math.min(v.duration||0,(v.currentTime||0)+10);
      bumpAutoHide();
    }else{ (v.paused? v.play(): v.pause()); }
    S.lastTap=now; S.lastTapX=e.clientX;
  });
  wrap.addEventListener('dblclick', ()=>{ toggleFS(); });

  wrap.addEventListener('wheel', (e)=>{
    if(isAnyPanelOpen()) return;
    if(e.shiftKey){ e.preventDefault(); const sign=(e.deltaY>0?1:-1); v.currentTime=clamp((v.currentTime||0)+sign*10,0,v.duration||Number.MAX_SAFE_INTEGER); }
    else{ e.preventDefault(); v.volume=clamp((v.volume||0.9)+(e.deltaY>0?-0.05:0.05),0,1); $('#vol').value=v.volume; try{ localStorage.setItem('pc.vol', v.volume);}catch{} }
    bumpAutoHide();
  }, {passive:false});

  $('#btnBack').onclick=()=>{ v.currentTime=Math.max(0,(v.currentTime||0)-10); bumpAutoHide(); };
  $('#btnFwd').onclick =()=>{ v.currentTime=Math.min((v.duration||0),(v.currentTime||0)+10); bumpAutoHide(); };

  // Seek
  const startDrag=()=>{ S.dragging=true; showUI(); seekTip.classList.add('show'); updateSeekTip(); };
  const endDrag =()=>{ S.dragging=false; seekTip.classList.remove('show'); bumpAutoHide(); };
  seekEl.addEventListener('input', ()=>{ const p=+seekEl.value/1000; $('#cur').textContent=fmt((v.duration||0)*p); updateSeekTip(); });
  seekEl.addEventListener('change',()=>{ const p=+seekEl.value/1000; v.currentTime=(v.duration||0)*p; endDrag(); });
  seekEl.addEventListener('mousedown', startDrag); seekEl.addEventListener('mouseup', endDrag);
  seekEl.addEventListener('touchstart', startDrag, {passive:true}); seekEl.addEventListener('touchend', endDrag);

  // volume / rate
  $('#vol').addEventListener('input', e=>{ v.volume=+e.target.value; bumpAutoHide(); });
  const rateSel=$('#rateSel');
  function setPlaybackRateFromSelect(){ const val=parseFloat(rateSel.value); v.playbackRate=isFinite(val)?val:1.0; try{ localStorage.setItem('pc.rate.'+(S.lastUrl||'default'), String(v.playbackRate)); }catch{} }
  rateSel.addEventListener('change', ()=>{ setPlaybackRateFromSelect(); bumpAutoHide(); });
  function stepRate(delta){ const opts=Array.from(rateSel.options).map(o=>parseFloat(o.value)); const cur=parseFloat(rateSel.value); let idx=opts.findIndex(x=>x===cur); if(idx<0) idx=Math.max(0,opts.findIndex(x=>x===1.0)); idx=Math.min(Math.max(idx+delta,0),opts.length-1); rateSel.value=opts[idx].toFixed(2); setPlaybackRateFromSelect(); }

  // Sleep timer
  const sleepSel = $('#sleepSel');
  function applySleep(){ S.sleepLeft = parseInt(sleepSel.value||'0',10); clearInterval(S.sleepTimer); if (S.sleepLeft>0){ S.sleepTimer=setInterval(()=>{ if(!v.paused){ S.sleepLeft -= 1; updateSleepBadge(); if (S.sleepLeft<=0){ clearInterval(S.sleepTimer); v.pause(); } } }, 1000); } else { setBadge(v.paused ? (S.loopOn? I[LANG].badge_pause_loop: I[LANG].badge_pause) : (S.loopOn? I[LANG].badge_play_loop : I[LANG].badge_play)); } }
  function updateSleepBadge(){ if (S.sleepLeft>0){ const mm=Math.floor(S.sleepLeft/60).toString(); const ss=Math.floor(S.sleepLeft%60).toString().padStart(2,'0'); const suffix=` • ${mm}:${ss}`; const base=v.paused ? (S.loopOn? I[LANG].badge_pause_loop: I[LANG].badge_pause) : (S.loopOn? I[LANG].badge_play_loop : I[LANG].badge_play); setBadge(base+suffix); } }
  sleepSel.addEventListener('change', applySleep);

  // PiP / FS
  async function togglePiP(){ try{ if(document.pictureInPictureElement) await document.exitPictureInPicture(); else await v.requestPictureInPicture(); }catch(e){ setBadge('PiP NG') } }
  async function toggleFS(){ try{ if(!document.fullscreenElement){ await wrap.requestFullscreen?.(); } else { await document.exitFullscreen?.(); } }catch{} }
  $('#btnPip').onclick=()=>{ togglePiP(); bumpAutoHide(); };
  $('#btnFs').onclick =()=>{ toggleFS();  bumpAutoHide(); };
  document.addEventListener('fullscreenchange', ()=> bumpAutoHide());

  // URL / HLS / File
  function isHls(u){ return /\.m3u8($|\?)/i.test(u) }
  function stopHls(){ if(S._hls){ try{ S._hls.destroy() }catch(e){} S._hls=null } }
  function revokeBlob(){ if(S.lastBlobUrl){ try{ URL.revokeObjectURL(S.lastBlobUrl) }catch{} S.lastBlobUrl=null; } }
  async function openUrl(u){
    if(!u) return; stopHls(); revokeBlob(); v.removeAttribute('src'); v.load();
    S.lastUrl=u; try{ localStorage.setItem('pc.lastUrl', u);}catch{}
    try{ const r = parseFloat(localStorage.getItem('pc.rate.'+S.lastUrl)||'NaN'); if(isFinite(r)){ rateSel.value=r.toFixed(2); setPlaybackRateFromSelect(); } }catch{}
    if(isHls(u) && window.Hls && Hls.isSupported()){
      S._hls=new Hls({enableWorker:false}); S._hls.attachMedia(v);
      S._hls.on(Hls.Events.MEDIA_ATTACHED, ()=> S._hls.loadSource(u));
      S._hls.on(Hls.Events.MANIFEST_PARSED, async ()=>{ await OPAudio.ensure(v); attachSpectrumNow(); try{ await v.play(); }catch{} tap.classList.add('hide'); });
    }else{
      v.src=u;
      v.onloadedmetadata=async ()=>{ await OPAudio.ensure(v); attachSpectrumNow(); try{ await v.play(); }catch{} tap.classList.add('hide'); v.onloadedmetadata=null; };
    }
  }
  $('#openUrl').onclick=()=>{ openUrl(($('#url').value||'').trim()); };

  function openLocalFile(file){
    if(!file) return; stopHls(); revokeBlob(); v.removeAttribute('src'); v.load();
    const url=URL.createObjectURL(file); S.lastBlobUrl=url; S.lastUrl='file:'+file.name;
    try{ const r = parseFloat(localStorage.getItem('pc.rate.'+S.lastUrl)||'NaN'); if(isFinite(r)){ rateSel.value=r.toFixed(2); setPlaybackRateFromSelect(); } }catch{}
    v.src=url; attachSpectrumNow(); v.play().catch(()=>{}); tap.classList.add('hide');
  }
  $('#file').addEventListener('change', e=>{ S.fileList=Array.from(e.target.files||[]); S.fileIndex=0; openLocalFile(S.fileList[0]); });

  // captions
  function srtToVtt(srt){ const vtt='WEBVTT\n\n'+String(srt).replace(/\r/g,'').replace(/^(\d+)\s*$/gm,'').replace(/(\d\d:\d\d:\d\d),(\d{3})/g,'$1.$2'); return new Blob([vtt],{type:'text/vtt'}); }
  function applySubStyle(){ const size=+$('#subSize').value||28, outline=+$('#subOutline').value||3, margin=+$('#subMargin').value||30; let style=document.getElementById('sub-style'); if(!style){ style=document.createElement('style'); style.id='sub-style'; document.head.appendChild(style); }
    style.textContent='video::cue{font-family:"Noto Sans JP",system-ui;font-size:'+size+'px;line-height:1.2;color:#fff;text-shadow:0 0 '+outline+'px rgba(0,0,0,.9);} video::-webkit-media-text-track-container{ transform:translateY(-'+margin+'px);} '; }
  function unloadTracks(){ Array.from(v.querySelectorAll('track')).forEach(t=>t.remove()); S.subTrack=null }
  function shiftCuesBy(offsetMs){ const trk=S.subTrack; if(!trk||!trk.cues) return; const off=(offsetMs|0)/1000; try{ for(let i=0;i<trk.cues.length;i++){ const c=trk.cues[i]; if(c && typeof c.startTime==='number'){ if(c._origStart==null){ c._origStart=c.startTime; c._origEnd=c.endTime; } const ns=c._origStart+off, ne=c._origEnd+off; c.startTime=Math.max(ns,0); c.endTime=Math.max(ne,0.01);} } }catch{} }
  $('#subFile').addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; unloadTracks(); let blob; if(f.name.endsWith('.vtt')) blob=new Blob([await f.text()],{type:'text/vtt'}); else blob=srtToVtt(await f.text()); const url=URL.createObjectURL(blob); const tr=document.createElement('track'); tr.kind='subtitles'; tr.label='ext'; tr.srclang=(LANG==='ja'?'ja':'en'); tr.default=true; tr.src=url; v.appendChild(tr); tr.addEventListener('load', ()=>{ tr.track.mode='showing'; S.subTrack=tr.track; shiftCuesBy(S.subOffset); }); });
  $('#btnSubClear').onclick=()=> unloadTracks();
  ['#subSize','#subOutline','#subMargin'].forEach(sel=> $(sel).addEventListener('input', applySubStyle));
  applySubStyle(); $('#subOffset').addEventListener('change', e=>{ S.subOffset=(+e.target.value)||0; shiftCuesBy(S.subOffset); });

  // Panels
  const showPanel=(scrim)=>{ scrim.classList.add('show'); showUI(); };
  const hidePanel=(scrim)=>{ scrim.classList.remove('show'); bumpAutoHide(); };
  $('#btnSettings').onclick=()=> showPanel($('#settingsScrim'));
  $('#btnTips').onclick    =()=> showPanel($('#tipsScrim'));
  $('#btnCloseSettings').onclick=()=> hidePanel($('#settingsScrim'));
  $('#btnCloseTips').onclick    =()=> hidePanel($('#tipsScrim'));
  $('#settingsScrim').addEventListener('click', (e)=>{ if(e.target===e.currentTarget) hidePanel(e.currentTarget) });
  $('#tipsScrim').addEventListener('click',     (e)=>{ if(e.target===e.currentTarget) hidePanel(e.currentTarget) });

  // Loop (A/B/L)
  function updateLoopBadge(){ const on=S.loopOn && S.loopA!=null && S.loopB!=null && S.loopB>S.loopA; $('#btnLoop').classList.toggle('active', on);
    setBadge(v.paused ? (on? I[LANG].badge_pause_loop: I[LANG].badge_pause) : (on? I[LANG].badge_play_loop : I[LANG].badge_play)); }
  $('#btnLoop').onclick=()=>{ S.loopOn=!S.loopOn; updateLoopBadge(); };

  // Keys
  document.addEventListener('keydown', (e)=>{
    const tag=(document.activeElement?.tagName||'').toLowerCase(); const inForm=(tag==='input'||tag==='textarea'||tag==='select');
    if(inForm && e.key!=='Escape') return;
    if(e.key==='Escape'){ hidePanel($('#settingsScrim')); hidePanel($('#tipsScrim')); showUI(); }
    if(e.key===' '){ e.preventDefault(); $('#btnPlay').click(); }
    if(e.key==='ArrowLeft'){ $('#btnBack').click(); }
    if(e.key==='ArrowRight'){ $('#btnFwd').click(); }
    if(e.key==='['){ stepRate(-1); }
    if(e.key===']'){ stepRate(+1); }
    if(e.key==='f' || e.key==='F'){ toggleFS(); }
    if(e.key==='p' || e.key==='P'){ togglePiP(); }
    if(e.key==='m' || e.key==='M'){ v.muted=!v.muted; setBadge(v.muted? I[LANG].badge_muted : (S.loopOn? I[LANG].badge_play_loop: I[LANG].badge_play)); }
    if(e.key==='s' || e.key==='S'){ saveFramePNG(); }
    if(e.key==='A'){ S.loopA=v.currentTime||0; S.loopOn=true; updateLoopBadge(); }
    if(e.key==='B'){ S.loopB=v.currentTime||0; S.loopOn=true; updateLoopBadge(); }
    if(e.key==='L'){ S.loopOn=!S.loopOn; updateLoopBadge(); }
    if(e.key==='?'){ showPanel($('#tipsScrim')); }
    if(/^[0-9]$/.test(e.key) && isFinite(v.duration)){ v.currentTime = v.duration * (+e.key/10) }
    bumpAutoHide();
  });

  // keep UI awake
  ['mousemove','pointermove','keydown','touchstart'].forEach(ev=>{ document.addEventListener(ev, ()=> bumpAutoHide(), {passive:true}); });

  // Spectrum UI
  const bindSpectrumUI=()=>{
    $('#specMode').addEventListener('change', e=>{ OPSpectrum.setMode(e.target.value); OPSpectrum.attach(v, wrap); });
    $('#specDist').addEventListener('change', e=>{ OPSpectrum.setDist(e.target.value); OPSpectrum.attach(v, wrap); });
    $('#specTilt').addEventListener('input',  e=>{ OPSpectrum.setTilt(parseFloat(e.target.value)); });
    $('#specSens').addEventListener('input', e=> OPSpectrum.sens=+e.target.value);
    $('#specBins').addEventListener('input', e=>{ OPSpectrum.bins=+e.target.value; OPSpectrum.attach(v, wrap); });
    $('#gridFx').addEventListener('change', e=>{ OPSpectrum.setGrid(e.target.value==='on'); try{ localStorage.setItem('pc.gridfx', e.target.value); }catch{} });
    OPSpectrum.attach(v, wrap);
  };

  // FX preset (背景)
  $('#fxPreset').addEventListener('change', (e)=>{
    const root = wrap.querySelector('.opfx'); const ps=['minimal','clean','glow','neon'];
    root.classList.remove(...ps.map(p=>'preset-'+p));
    const val = e.target.value; root.classList.add('preset-'+(ps.includes(val)?val:'minimal'));
  });

  // PNG frame save
  function saveFramePNG(){ try{ const c=document.createElement('canvas'); const r=wrap.getBoundingClientRect(); c.width=Math.floor(r.width); c.height=Math.floor(r.height);
    const g=c.getContext('2d'); g.drawImage(v,0,0,c.width,c.height); const url=c.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='frame_'+Date.now()+'.png'; a.click();
    setBadge(I[LANG].badge_shot); setTimeout(()=> setBadge(v.paused?(S.loopOn? I[LANG].badge_pause_loop: I[LANG].badge_pause):(S.loopOn? I[LANG].badge_play_loop: I[LANG].badge_play)), 1200);
  }catch{ setBadge('SHOT NG'); } }

  // ===== EQ UI =====
  const FREQS = window.OPAudio_FREQS || [32,64,125,250,500,1000,2000,4000,8000,16000];
  function renderEqBands(){
    const box = $('#eqBands'); box.innerHTML='';
    const gains = (window.OPAudio && OPAudio.filters.length) ? OPAudio.getGains() : (new Array(FREQS.length).fill(0));
    for(let i=0;i<FREQS.length;i++){
      const row = document.createElement('div'); row.className='eq-band';
      const lab = document.createElement('label'); lab.textContent = (FREQS[i]>=1000? (FREQS[i]/1000)+'k':FREQS[i]) + 'Hz';
      const out = document.createElement('output'); out.id = 'eqOut'+i; out.textContent = (gains[i]||0).toFixed(1) + 'dB';
      const slider = document.createElement('input'); slider.type='range'; slider.min='-12'; slider.max='12'; slider.step='0.5';
      slider.value = gains[i]||0; slider.id='eq'+i; slider.addEventListener('input', (e)=>{
        const val = parseFloat(e.target.value);
        out.textContent = val.toFixed(1) + 'dB';
        try{ OPAudio.setBand(i, val); $('#eqPreset').value='custom'; }catch{}
      });
      row.appendChild(lab); row.appendChild(slider); row.appendChild(out);
      box.appendChild(row);
    }
  }
  function applyEqEnabledUI(on){ $('#eqEnable').value = on ? 'on':'off'; }
  $('#eqEnable').addEventListener('change', (e)=>{ const on=e.target.value==='on'; try{ OPAudio.setEnabled(on); }catch{} applyEqEnabledUI(on); });
  $('#eqReset').addEventListener('click', ()=>{ try{ OPAudio.setPreset('flat'); $('#eqPreset').value='flat'; }catch{} renderEqBands(); });
  $('#eqPreset').addEventListener('change', (e)=>{ const p=e.target.value; try{ OPAudio.setPreset(p); }catch{} renderEqBands(); });

  // ===== Boot =====
  window.addEventListener('DOMContentLoaded', ()=>{
    applyLang(); bindSpectrumUI(); attachSpectrumNow(18);

    // 既定でグリッドFX
    try{ const savedGrid = localStorage.getItem('pc.gridfx') || 'on'; $('#gridFx').value=savedGrid; OPSpectrum.setGrid(savedGrid==='on'); }catch{}

    // デバイス判定して、初回はオーバーレイ表示
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    if (!isMobile){ tap.classList.add('hide'); } // PCは不要
    renderEqBands();
    applyEqEnabledUI(window.OPAudio ? OPAudio.eqEnabled : true);
  });

  // init prefs
  try{ v.volume=+localStorage.getItem('pc.vol')||0.9 }catch(e){}
  $('#vol').value=v.volume;
  (function syncRateSel(){ const opts=Array.from($('#rateSel').options).map(o=>parseFloat(o.value)); const cur=v.playbackRate||1.0; let idx=0, best=Infinity; for(let i=0;i<opts.length;i++){ const d=Math.abs(opts[i]-cur); if(d<best){best=d; idx=i;} } $('#rateSel').value=opts[idx].toFixed(2); })();
  setPlaybackRateFromSelect();
  applySleep();

  // Helpers
  function applySleep(){ /* already defined above */ }
  function saveFramePNG(){ /* already defined above */ }

})();
</script>
</body>
</html>
